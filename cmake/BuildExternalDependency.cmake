cmake_minimum_required(VERSION 3.16...3.19)
include(FetchContent)

# ##############################################################################
# BuildExternalDependency
# ##############################################################################
#
# Simplified version of Framework's BuildExternalDependency for building
# external dependencies, with special handling for FFmpeg.
#

function(BuildExternalDependency name)
  message(STATUS "Processing external dependency ${name}")

  # Option groups
  set(flags INTERFACE NO_INSTALL FORCE_FETCH CUSTOM_BUILD)
  set(single_val GIT_REPOSITORY GIT_TAG SOURCE_SUBDIR)
  set(multi_val CMAKE_ARGS PATCH_COMMAND GIT_SUBMODULES)

  cmake_parse_arguments(PARSE_ARGV 1 ${name} "${flags}" "${single_val}" "${multi_val}")

  # Check if all required args are present
  if(NOT DEFINED ${name}_GIT_REPOSITORY)
    message(FATAL_ERROR "GIT_REPOSITORY for ${name} not set")
  endif()

  if("${${name}_GIT_TAG}" STREQUAL "")
    message(FATAL_ERROR "GIT_TAG required for ${name} BuildExternalDependency")
  else()
    set(GIT_TAG "GIT_TAG" ${${name}_GIT_TAG})
  endif()

  string(LENGTH ${${name}_GIT_TAG} GIT_TAG_LENGTH)

  # GIT_SHALLOW ON does not work for explicit commit hash
  if(GIT_TAG_LENGTH EQUAL 40)
    message(AUTHOR_WARNING "${name} git commit hash specified. Cannot do shallow clone.")
  else()
    set(GIT_SHALLOW GIT_SHALLOW ON)
  endif()

  # Change CMake's default to require defining submodules manually
  if(NOT DEFINED ${name}_GIT_SUBMODULES)
    set(GIT_SUBMODULES GIT_SUBMODULES "")
  else()
    set(GIT_SUBMODULES GIT_SUBMODULES ${${name}_GIT_SUBMODULES})
  endif()

  # FetchContent changes all target names to lowercase
  string(TOLOWER ${name} name_lowercase)
  set(fetchcontent_target "${name_lowercase}")

  option(BuildExternalDependency_BASE_DIR "Where to place external dependencies" ${FETCHCONTENT_BASE_DIR})

  # These are the directories that would normally be generated by the FetchContent target
  set(${fetchcontent_target}_SOURCE_DIR ${BuildExternalDependency_BASE_DIR}/${fetchcontent_target}-src)
  set(${fetchcontent_target}_BINARY_DIR ${BuildExternalDependency_BASE_DIR}/${fetchcontent_target}-build)
  set(${fetchcontent_target}_SUBBUILD_DIR ${BuildExternalDependency_BASE_DIR}/${fetchcontent_target}-subbuild)
  set(${fetchcontent_target}_INSTALL_DIR ${BuildExternalDependency_BASE_DIR}/${fetchcontent_target}-install)

  set(FETCHCONTENT_QUIET OFF CACHE BOOL "" FORCE)
  FetchContent_Declare(
    ${fetchcontent_target}
    GIT_REPOSITORY "${${name}_GIT_REPOSITORY}"
    ${GIT_TAG}
    ${GIT_SHALLOW}
    GIT_PROGRESS OFF
    ${GIT_SUBMODULES}
    PATCH_COMMAND "${${name}_PATCH_COMMAND}"
    SOURCE_DIR ${${fetchcontent_target}_SOURCE_DIR}
    BINARY_DIR ${${fetchcontent_target}_BINARY_DIR}
    SUBBUILD_DIR ${${fetchcontent_target}_SUBBUILD_DIR}
  )

  string(SHA256 GIT_TAG_HASH "${${name}_GIT_TAG}")
  set(CHECKPOINT_FILENAME_PREFIX ${${fetchcontent_target}_BINARY_DIR}/${name})
  set(FETCH_CHECKPOINT_NAME ${CHECKPOINT_FILENAME_PREFIX}_${GIT_TAG_HASH})

  FetchContent_GetProperties(${fetchcontent_target})
  if(${name}_FORCE_FETCH OR (NOT EXISTS ${FETCH_CHECKPOINT_NAME} AND NOT ${fetchcontent_target}_POPULATED))
    message(STATUS "Syncing ${name} from ${${name}_GIT_REPOSITORY} to ${${fetchcontent_target}_SOURCE_DIR}...")
    FetchContent_Populate(${fetchcontent_target})
    if(${fetchcontent_target}_POPULATED)
      file(TOUCH ${FETCH_CHECKPOINT_NAME})
      message(STATUS "Done syncing ${name}")
    else()
      message(FATAL_ERROR "Failed syncing ${name}")
    endif()
  endif()

  if(${name}_INTERFACE)
    # download header-only libraries then create a fake interface target
    add_library(${name} INTERFACE IMPORTED)
    target_include_directories(${name} INTERFACE "${${fetchcontent_target}_SOURCE_DIR}/${${name}_SOURCE_SUBDIR}")
  elseif(${name}_CUSTOM_BUILD)
    # Special handling for FFmpeg
    if(name STREQUAL "ffmpeg")
      include(BuildFFmpeg)
      BuildFFmpeg(
        ${${fetchcontent_target}_SOURCE_DIR}
        ${${fetchcontent_target}_BINARY_DIR}
        ${${fetchcontent_target}_INSTALL_DIR}
      )
    endif()
  else()
    # Standard CMake-based build
    string(SHA256 CONFIG_HASH "${ARGV}")
    message(STATUS "Note: SHA256=${CONFIG_HASH} is computed from ARGV=(${ARGV})")

    set(NEEDS_REBUILD OFF)

    message(STATUS "Expecting configurations ${CMAKE_CONFIGURATION_TYPES}")
    foreach(CONFIG ${CMAKE_CONFIGURATION_TYPES})
      set(CHECKPOINT_NAME ${CHECKPOINT_FILENAME_PREFIX}_build_${CONFIG}_${CONFIG_HASH})
      if(NOT EXISTS ${CHECKPOINT_NAME})
        message(STATUS "Determined need for rebuild of ${name}. Could not find checkpoint file for config ${CONFIG} (expected file: ${CHECKPOINT_NAME})")
        set(NEEDS_REBUILD ON)
      endif()
    endforeach()

    if(NEEDS_REBUILD)
      # Configure
      if(${name}_SOURCE_SUBDIR)
        set(SOURCE_DIR ${${fetchcontent_target}_SOURCE_DIR}/${${name}_SOURCE_SUBDIR})
      else()
        set(SOURCE_DIR ${${fetchcontent_target}_SOURCE_DIR})
      endif()

      foreach(CONFIG ${CMAKE_CONFIGURATION_TYPES})
        message(STATUS "Configuring ${name} for configuration: ${CONFIG}")

        execute_process(
          COMMAND
            ${CMAKE_COMMAND}
            -Wno-dev
            -DCMAKE_BUILD_TYPE=${CONFIG}
            -G ${CMAKE_GENERATOR}
            ${${name}_CMAKE_ARGS}
            -S ${SOURCE_DIR}
            -B ${${fetchcontent_target}_BINARY_DIR}-${CONFIG}
          COMMAND_ECHO STDOUT
          RESULT_VARIABLE CONFIGURE_EXEC_RESULT
        )
        if(NOT CONFIGURE_EXEC_RESULT EQUAL 0)
          message(FATAL_ERROR "Configure for ${name} failed with exit code ${CONFIGURE_EXEC_RESULT}")
        endif()
      endforeach()

      # Build
      foreach(CONFIG ${CMAKE_CONFIGURATION_TYPES})
        include(ProcessorCount)
        ProcessorCount(BUILD_THREADS)

        execute_process(
          COMMAND
            ${CMAKE_COMMAND}
            --build ${${fetchcontent_target}_BINARY_DIR}-${CONFIG}
            --parallel ${BUILD_THREADS}
            --config ${CONFIG}
          COMMAND_ECHO STDOUT
          RESULT_VARIABLE BUILD_EXEC_RESULT
        )
        if(NOT BUILD_EXEC_RESULT EQUAL 0)
          message(FATAL_ERROR "Build for ${name} failed with exit code ${BUILD_EXEC_RESULT}")
        endif()
      endforeach()

      # Install
      foreach(CONFIG ${CMAKE_CONFIGURATION_TYPES})
        execute_process(
          COMMAND
            ${CMAKE_COMMAND}
            --install ${${fetchcontent_target}_BINARY_DIR}-${CONFIG}
            --prefix ${${fetchcontent_target}_INSTALL_DIR}
            --config ${CONFIG}
          OUTPUT_QUIET
          COMMAND_ECHO STDOUT
          RESULT_VARIABLE INSTALL_EXEC_RESULT
        )
        if(NOT INSTALL_EXEC_RESULT EQUAL 0)
          message(FATAL_ERROR "INSTALL for ${name} failed with exit code ${INSTALL_EXEC_RESULT}")
        endif()
      endforeach()

      # Try to find the package
      find_package(${name} QUIET CONFIG PATHS ${${fetchcontent_target}_INSTALL_DIR} NO_DEFAULT_PATH)
      if(NOT ${name}_FOUND)
        message(STATUS "${name} package config not found, but build succeeded")
      endif()
    endif()

    # Checkpoint
    foreach(CONFIG ${CMAKE_CONFIGURATION_TYPES})
      file(GLOB OLD_CHECKPOINTS_FOR_CONFIG ${CHECKPOINT_FILENAME_PREFIX}_build_${CONFIG}_*)
      if(OLD_CHECKPOINTS_FOR_CONFIG)
        file(REMOVE ${OLD_CHECKPOINTS_FOR_CONFIG})
      endif()
      set(CHECKPOINT_NAME ${CHECKPOINT_FILENAME_PREFIX}_build_${CONFIG}_${CONFIG_HASH})
      file(TOUCH ${CHECKPOINT_NAME})
    endforeach()
  endif()

  # Export variables to parent scope
  set(${fetchcontent_target}_SOURCE_DIR ${${fetchcontent_target}_SOURCE_DIR} PARENT_SCOPE)
  set(${fetchcontent_target}_BINARY_DIR ${${fetchcontent_target}_BINARY_DIR} PARENT_SCOPE)
  set(${fetchcontent_target}_INSTALL_DIR ${${fetchcontent_target}_INSTALL_DIR} PARENT_SCOPE)

endfunction()

